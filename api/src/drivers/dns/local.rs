use super::{DnsProvider, DnsError, DnsRecord, DnsZone, DnsZoneInfo, DnssecKey};
use async_trait::async_trait;
use std::collections::HashMap;
use std::fs;
use std::path::PathBuf;
use tokio::sync::RwLock;

/// Local DNS provider that manages DNS zones using bind-style zone files
/// This is useful for testing and small deployments where external DNS providers aren't needed
#[derive(Debug)]
pub struct LocalDns {
    zones_dir: PathBuf,
    zones: RwLock<HashMap<String, LocalZoneData>>,
}

#[derive(Debug, Clone)]
struct LocalZoneData {
    zone_info: DnsZoneInfo,
    records: Vec<DnsRecord>,
}

impl LocalDns {
    pub fn new<P: Into<PathBuf>>(zones_dir: P) -> Result<Self, DnsError> {
        let zones_dir = zones_dir.into();
        
        // Create zones directory if it doesn't exist
        if let Err(e) = std::fs::create_dir_all(&zones_dir) {
            return Err(DnsError::ApiError(format!("Failed to create zones directory: {}", e)));
        }

        Ok(LocalDns {
            zones_dir,
            zones: RwLock::new(HashMap::new()),
        })
    }

    async fn load_zone_from_file(&self, zone_id: &str) -> Result<LocalZoneData, DnsError> {
        let zone_file = self.zones_dir.join(format!("{}.zone", zone_id));
        
        if !zone_file.exists() {
            return Err(DnsError::ZoneNotFound { zone: zone_id.to_string() });
        }

        let content = fs::read_to_string(&zone_file)
            .map_err(|e| DnsError::ApiError(format!("Failed to read zone file: {}", e)))?;

        self.parse_zone_file(zone_id, &content).await
    }

    async fn save_zone_to_file(&self, zone_id: &str, zone_data: &LocalZoneData) -> Result<(), DnsError> {
        let zone_file = self.zones_dir.join(format!("{}.zone", zone_id));
        let zone_content = self.generate_zone_file(zone_data).await?;
        
        fs::write(&zone_file, zone_content)
            .map_err(|e| DnsError::ApiError(format!("Failed to write zone file: {}", e)))?;
        
        Ok(())
    }

    async fn parse_zone_file(&self, zone_id: &str, content: &str) -> Result<LocalZoneData, DnsError> {
        let mut records = Vec::new();
        let mut zone_name = zone_id.to_string();
        
        for (line_num, line) in content.lines().enumerate() {
            let line = line.trim();
            
            // Skip comments and empty lines
            if line.starts_with(';') || line.is_empty() {
                continue;
            }

            // Parse SOA record and other records
            if line.contains("SOA") {
                // Extract zone name from SOA record
                if let Some(name_part) = line.split_whitespace().next() {
                    if name_part != "@" {
                        zone_name = name_part.trim_end_matches('.').to_string();
                    }
                }
                continue; // Skip SOA parsing for simplicity
            }

            // Parse regular DNS records
            let parts: Vec<&str> = line.split_whitespace().collect();
            if parts.len() < 4 {
                continue; // Skip malformed lines
            }

            let name = if parts[0] == "@" {
                zone_name.clone()
            } else {
                parts[0].trim_end_matches('.').to_string()
            };

            let ttl = parts[1].parse::<u32>().unwrap_or(3600);
            let record_type = parts[3].to_string();
            let content = parts[4..].join(" ");

            records.push(DnsRecord {
                id: Some(format!("{}-{}-{}", name, record_type, records.len())),
                zone_id: zone_id.to_string(),
                name,
                record_type,
                content,
                ttl,
                priority: None,
                proxied: None,
            });
        }

        Ok(LocalZoneData {
            zone_info: DnsZoneInfo {
                id: zone_id.to_string(),
                name: zone_name,
                status: "active".to_string(),
                name_servers: vec!["localhost".to_string()],
                dnssec_enabled: false,
            },
            records,
        })
    }

    async fn generate_zone_file(&self, zone_data: &LocalZoneData) -> Result<String, DnsError> {
        let mut content = String::new();
        
        content.push_str(&format!(
            "; Zone file for {}\n",
            zone_data.zone_info.name
        ));
        content.push_str(&format!("; Generated by GhostCP Local DNS Provider\n\n"));

        // Add SOA record
        content.push_str(&format!(
            "{}.\t3600\tIN\tSOA\tlocalhost. admin.{}. 1 3600 1800 1209600 86400\n",
            zone_data.zone_info.name,
            zone_data.zone_info.name
        ));

        // Add NS record
        content.push_str(&format!(
            "{}.\t3600\tIN\tNS\tlocalhost.\n\n",
            zone_data.zone_info.name
        ));

        // Add other records
        for record in &zone_data.records {
            if record.record_type == "SOA" || record.record_type == "NS" {
                continue; // Already added above
            }

            let name = if record.name == zone_data.zone_info.name {
                "@".to_string()
            } else {
                record.name.clone()
            };

            content.push_str(&format!(
                "{}\t{}\tIN\t{}\t{}\n",
                name,
                record.ttl,
                record.record_type,
                record.content
            ));
        }

        Ok(content)
    }
}

#[async_trait]
impl DnsProvider for LocalDns {
    fn provider_name(&self) -> &'static str {
        "local"
    }

    async fn health_check(&self) -> Result<(), DnsError> {
        // Check if zones directory exists and is writable
        if !self.zones_dir.exists() {
            return Err(DnsError::ApiError("Zones directory does not exist".to_string()));
        }

        // Try to create a test file
        let test_file = self.zones_dir.join(".test");
        match fs::write(&test_file, "test") {
            Ok(_) => {
                let _ = fs::remove_file(&test_file);
                Ok(())
            }
            Err(e) => Err(DnsError::ApiError(format!("Zones directory not writable: {}", e))),
        }
    }

    async fn create_zone(&self, zone: &DnsZone) -> Result<DnsZoneInfo, DnsError> {
        let zone_id = zone.name.clone();
        
        let zone_data = LocalZoneData {
            zone_info: DnsZoneInfo {
                id: zone_id.clone(),
                name: zone.name.clone(),
                status: "active".to_string(),
                name_servers: vec![zone.primary_ns.clone()],
                dnssec_enabled: zone.dnssec_enabled,
            },
            records: Vec::new(),
        };

        // Save to file
        self.save_zone_to_file(&zone_id, &zone_data).await?;
        
        // Cache in memory
        self.zones.write().await.insert(zone_id.clone(), zone_data.clone());

        Ok(zone_data.zone_info)
    }

    async fn get_zone(&self, zone_id: &str) -> Result<DnsZoneInfo, DnsError> {
        // Try memory cache first
        if let Some(zone_data) = self.zones.read().await.get(zone_id) {
            return Ok(zone_data.zone_info.clone());
        }

        // Load from file
        let zone_data = self.load_zone_from_file(zone_id).await?;
        let zone_info = zone_data.zone_info.clone();
        
        // Cache in memory
        self.zones.write().await.insert(zone_id.to_string(), zone_data);
        
        Ok(zone_info)
    }

    async fn list_zones(&self) -> Result<Vec<DnsZoneInfo>, DnsError> {
        let mut zones = Vec::new();
        
        // Read from zones directory
        let dir_entries = fs::read_dir(&self.zones_dir)
            .map_err(|e| DnsError::ApiError(format!("Failed to read zones directory: {}", e)))?;

        for entry in dir_entries {
            let entry = entry.map_err(|e| DnsError::ApiError(e.to_string()))?;
            let path = entry.path();
            
            if let Some(extension) = path.extension() {
                if extension == "zone" {
                    if let Some(zone_name) = path.file_stem().and_then(|s| s.to_str()) {
                        match self.get_zone(zone_name).await {
                            Ok(zone_info) => zones.push(zone_info),
                            Err(_) => continue, // Skip malformed zones
                        }
                    }
                }
            }
        }

        Ok(zones)
    }

    async fn update_zone(&self, zone_id: &str, zone: &DnsZone) -> Result<(), DnsError> {
        let mut zone_data = self.load_zone_from_file(zone_id).await?;
        
        // Update zone info
        zone_data.zone_info.name = zone.name.clone();
        zone_data.zone_info.name_servers = vec![zone.primary_ns.clone()];
        zone_data.zone_info.dnssec_enabled = zone.dnssec_enabled;
        
        // Save to file and cache
        self.save_zone_to_file(zone_id, &zone_data).await?;
        self.zones.write().await.insert(zone_id.to_string(), zone_data);
        
        Ok(())
    }

    async fn delete_zone(&self, zone_id: &str) -> Result<(), DnsError> {
        let zone_file = self.zones_dir.join(format!("{}.zone", zone_id));
        
        if zone_file.exists() {
            fs::remove_file(&zone_file)
                .map_err(|e| DnsError::ApiError(format!("Failed to delete zone file: {}", e)))?;
        }
        
        // Remove from cache
        self.zones.write().await.remove(zone_id);
        
        Ok(())
    }

    async fn create_record(&self, record: &DnsRecord) -> Result<String, DnsError> {
        let mut zone_data = self.load_zone_from_file(&record.zone_id).await?;
        
        // Generate unique record ID
        let record_id = format!("{}-{}-{}", record.name, record.record_type, zone_data.records.len());
        
        let mut new_record = record.clone();
        new_record.id = Some(record_id.clone());
        
        zone_data.records.push(new_record);
        
        // Save and cache
        self.save_zone_to_file(&record.zone_id, &zone_data).await?;
        self.zones.write().await.insert(record.zone_id.clone(), zone_data);
        
        Ok(record_id)
    }

    async fn get_record(&self, zone_id: &str, record_id: &str) -> Result<DnsRecord, DnsError> {
        let zone_data = self.load_zone_from_file(zone_id).await?;
        
        zone_data.records.into_iter()
            .find(|r| r.id.as_deref() == Some(record_id))
            .ok_or_else(|| DnsError::RecordNotFound { record_id: record_id.to_string() })
    }

    async fn list_records(&self, zone_id: &str, record_type: Option<&str>) -> Result<Vec<DnsRecord>, DnsError> {
        let zone_data = self.load_zone_from_file(zone_id).await?;
        
        let records = if let Some(filter_type) = record_type {
            zone_data.records.into_iter()
                .filter(|r| r.record_type == filter_type)
                .collect()
        } else {
            zone_data.records
        };
        
        Ok(records)
    }

    async fn update_record(&self, record_id: &str, record: &DnsRecord) -> Result<(), DnsError> {
        let mut zone_data = self.load_zone_from_file(&record.zone_id).await?;
        
        // Find and update the record
        let mut found = false;
        for existing_record in &mut zone_data.records {
            if existing_record.id.as_deref() == Some(record_id) {
                existing_record.name = record.name.clone();
                existing_record.record_type = record.record_type.clone();
                existing_record.content = record.content.clone();
                existing_record.ttl = record.ttl;
                existing_record.priority = record.priority;
                found = true;
                break;
            }
        }
        
        if !found {
            return Err(DnsError::RecordNotFound { record_id: record_id.to_string() });
        }
        
        // Save and cache
        self.save_zone_to_file(&record.zone_id, &zone_data).await?;
        self.zones.write().await.insert(record.zone_id.clone(), zone_data);
        
        Ok(())
    }

    async fn delete_record(&self, zone_id: &str, record_id: &str) -> Result<(), DnsError> {
        let mut zone_data = self.load_zone_from_file(zone_id).await?;
        
        // Find and remove the record
        let initial_len = zone_data.records.len();
        zone_data.records.retain(|r| r.id.as_deref() != Some(record_id));
        
        if zone_data.records.len() == initial_len {
            return Err(DnsError::RecordNotFound { record_id: record_id.to_string() });
        }
        
        // Save and cache
        self.save_zone_to_file(zone_id, &zone_data).await?;
        self.zones.write().await.insert(zone_id.to_string(), zone_data);
        
        Ok(())
    }

    async fn set_dnssec(&self, zone_id: &str, enabled: bool) -> Result<(), DnsError> {
        let mut zone_data = self.load_zone_from_file(zone_id).await?;
        zone_data.zone_info.dnssec_enabled = enabled;
        
        // Save and cache
        self.save_zone_to_file(zone_id, &zone_data).await?;
        self.zones.write().await.insert(zone_id.to_string(), zone_data);
        
        Ok(())
    }

    async fn get_dnssec_keys(&self, _zone_id: &str) -> Result<Vec<DnssecKey>, DnsError> {
        // Local DNS provider doesn't support DNSSEC key management
        Ok(Vec::new())
    }

    async fn import_zone(&self, zone_id: &str, zone_file: &str) -> Result<(), DnsError> {
        let zone_data = self.parse_zone_file(zone_id, zone_file).await?;
        
        // Save to file and cache
        self.save_zone_to_file(zone_id, &zone_data).await?;
        self.zones.write().await.insert(zone_id.to_string(), zone_data);
        
        Ok(())
    }

    async fn export_zone(&self, zone_id: &str) -> Result<String, DnsError> {
        let zone_data = self.load_zone_from_file(zone_id).await?;
        self.generate_zone_file(&zone_data).await
    }
}